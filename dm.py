
import math
from fractions import gcd 
import time
import random, sys, os, math
from random import randint

def pow_mod(x, y, z):
    "Calculate (x ** y) % z efficiently."
    number = 1
    while y:
        if int(y) & int(1):
            number = number * x % z
        y = int(y)
        y >>= 1
        x = x * x % z
    return number
martin_n = 239255299284384349304725149856552492038598445886956658797340414572081315025316855599003056773010145489861807217942474066769254994889937350554812114599199747011822931003470188469755565575428252755498450043694308433269873821720504733262583005940196298951811543171416951549542705533417999736765774452030314635913103516225119401185982005668156650192848448135779911780427770251154346413709247810959979685820122190878080140819951259653464493002404315741219936122712441337048287859676453307655235582246940129654549936418104588280142515645148689690033053995534499764950491215574658031050257809925263610106291
martin_e = 51831672085074814178680269722598016921936838558306727005991561731670505910386509866184899294113023750765710594543251856658239666016521056714215727353889825219309912019100396570607753922542886645209401533085461587994461683838141339926725638136349726690307472237142348752101995510115124409635193574780938087738364459858781987481597603026016849697794677

p = 290245329165570025116016487217740287508837913295571609463914348778319654489118435855243301969001872061575755804802874062021927719647357060447135321577028929269578574760547268310055056867386875959045119093967972205124270441648450825188877095173754196346551952542599226295413057787340278528252358809329
q = 531872289054204184185084734375133399408303613982130856645299464930952178606045848877129147820387996428175564228204785846141207532462936339834139412401975338705794646595487324365194792822189473092273993580587964571659678084484152603881094176995594813302284232006001752128168901293560051833646881436219
#print(isprime(p), isprime(q))
# generate 2 300 digit number (p and q)
# check if they are prime (primality test, fermat test, rabin miller test)
n = p*q
phi = (p-1)*(q-1)
e = 70001
# pick an e co prime with phi
# find d such that ed = 1 (mod phi) (mod inverse?)
def LDEsolve(a,b,c=1):
	q, r = divmod(a,b)
	if r == 0:
		return( [0,math.trunc(c/b)] )
	else:
		sol = LDEsolve( b, r, c )
		u = sol[0]
		v = sol[1]
		return( [ math.trunc(v), math.trunc(u - q*v) ] )
d = LDEsolve(a=e, b =phi)[0]
#print(d)
#MY PUBLIC KEY = (e, n)
#MY PRIVATE KEY = (d, n)
M = 87104097116032105115032070111114114101115116032071117109112039115032101109097105108032112097115115119111114100063032082097098101101097032065104109097100032050048054050048048051056

C = pow_mod(x = M, y = martin_e, z = martin_n)
print("C = ", C)
print("n = ", n)
print("e = ", e)
#D = pow_mod(x = C, y = d, z = n)
#print("D = ", D)
#print(C, " = (", M, "**", e, "(mod", n, ")")

#encrypt message to martin pei with his e and n where 0<m<n
# C = M^e(mod n) (use square and multiply)

# post that in the excel file

#to decrpyt his response:
#D = his message ^ my d (mod my n)

